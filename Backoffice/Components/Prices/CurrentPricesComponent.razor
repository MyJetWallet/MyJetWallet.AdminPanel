@using MyJetWallet.Domain.Prices
@using MyJetWallet.Sdk.Service.Tools
@using Microsoft.Extensions.Logging
@using MyJetWallet.Domain
@using Service.AssetsDictionary.Client
@using Service.AssetsDictionary.Domain.Models
@using Service.IndexPrices.Client
@using Service.IndexPrices.Domain.Models
@using Syncfusion.Blazor.Diagrams

@inject ICurrentPricesClient _currentPricesClient


@implements IDisposable

<h3>Current Prices</h3>

<table class="table" style="width: auto; font-size: 10px;">
    <thead>
    <tr>
        <th>Source</th>
        <th>Market</th>
        <th>Price</th>
        <th>Status</th>
        <th>Instrument</th>
        <th>Timestamp</th>
        <th>Delay</th>
        <th></th>
    </tr>
    </thead>
    <tbody>
    @foreach (var price in _prices)
    {
        <tr style="background: @(GetRowBackground(price))">
            <td>@price.Source</td>
            <td>@price.SourceMarket</td>
            <td>@price.Price</td>
            <td>@price.InstrumentStatus.ToString()</td>
            <td>@price.InstrumentSymbol</td>
            <td>@price.DateTime.ToString("yyyy-MM-dd HH:mm:ss")</td>
            <td>@((DateTime.UtcNow - @price.DateTime).ToString())</td>
            <td>
                <ul class="nav">
                </ul>
            </td>
        </tr>
    }
    </tbody>
</table>


@code {

    private bool _isDispose = false;
    
    private List<CurrentPrice> _prices = new ();
    
    protected override async Task OnInitializedAsync()
    {

        await ReloadData();

        GlobalTimers.RefreshTimer.RegisterCallback(nameof(IndexPricesComponent), DoTime);
    }

    private async Task DoTime()
    {
        if (_isDispose) return;
        await ReloadData();
        await InvokeAsync(StateHasChanged);
    }

    private Task ReloadData()
    {
        var prices = _currentPricesClient.GetAllPrices();
        
        _prices.Clear();
        _prices.AddRange(prices
            .OrderBy(e => e.InstrumentStatus == CurrentPrice.Status.Enabled ? 0 : (e.InstrumentStatus == CurrentPrice.Status.Disabled ? 1 : 2))
            .ThenBy(e => e.InstrumentSymbol)
            .ThenBy(e => e.Source)
            .ThenBy(e => e.SourceMarket));


        return Task.CompletedTask;
    }

    public void Dispose()
    {
        _isDispose = true;
        GlobalTimers.RefreshTimer.RemoveCallback(nameof(Prices));
    }

    private string GetRowBackground(CurrentPrice price)
    {
        return (DateTime.UtcNow - price.DateTime).TotalMilliseconds > 5000 
            ? "lightgoldenrodyellow" 
            : "white";
    }

}